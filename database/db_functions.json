[
  {
    "function_name": "batch_insert_neighborhood_stats",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.batch_insert_neighborhood_stats(p_records jsonb)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  record JSONB;\n  inserted_count INTEGER := 0;\nBEGIN\n  FOR record IN SELECT * FROM jsonb_array_elements(p_records)\n  LOOP\n    INSERT INTO neighborhood_stats (\n      block_group_fips,\n      boundary,\n      name,\n      city,\n      state_code,\n      county_name,\n      population,\n      diversity_index,\n      pct_minority,\n      crime_rate_per_1000,\n      violent_crime_rate,\n      property_crime_rate,\n      hate_crime_incidents,\n      data_source,\n      data_year\n    ) VALUES (\n      record->>'block_group_fips',\n      ST_GeogFromText('SRID=4326;' || (record->>'boundary_wkt')),\n      record->>'name',\n      record->>'city',\n      record->>'state_code',\n      record->>'county_name',\n      (record->>'population')::INTEGER,\n      (record->>'diversity_index')::NUMERIC,\n      (record->>'pct_minority')::NUMERIC,\n      (record->>'crime_rate_per_1000')::NUMERIC,\n      (record->>'violent_crime_rate')::NUMERIC,\n      (record->>'property_crime_rate')::NUMERIC,\n      (record->>'hate_crime_incidents')::INTEGER,\n      record->>'data_source',\n      (record->>'data_year')::INTEGER\n    )\n    ON CONFLICT (block_group_fips) DO UPDATE SET\n      boundary = EXCLUDED.boundary,\n      name = EXCLUDED.name,\n      city = EXCLUDED.city,\n      county_name = EXCLUDED.county_name,\n      population = EXCLUDED.population,\n      diversity_index = EXCLUDED.diversity_index,\n      pct_minority = EXCLUDED.pct_minority,\n      crime_rate_per_1000 = EXCLUDED.crime_rate_per_1000,\n      violent_crime_rate = EXCLUDED.violent_crime_rate,\n      property_crime_rate = EXCLUDED.property_crime_rate,\n      hate_crime_incidents = EXCLUDED.hate_crime_incidents,\n      data_source = EXCLUDED.data_source,\n      data_year = EXCLUDED.data_year,\n      updated_at = NOW();\n    \n    inserted_count := inserted_count + 1;\n  END LOOP;\n  \n  RETURN inserted_count;\nEND;\n$function$\n"
  },
  {
    "function_name": "calculate_location_safety_scores",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.calculate_location_safety_scores(p_location_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Delete existing scores for this location\n  DELETE FROM safety_scores WHERE location_id = p_location_id;\n  \n  -- Calculate OVERALL scores (all users combined) with vote weighting\n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'overall', null,\n    -- Weighted averages based on helpful votes\n    (SUM(r.safety_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.comfort_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.overall_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  WHERE r.location_id = p_location_id \n    AND r.status = 'active'\n    -- Filter out spam reviews (negative vote ratio)\n    AND (1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2)) > 0\n  HAVING COUNT(*) > 0\n  ON CONFLICT (location_id, demographic_type, demographic_value) \n  DO UPDATE SET\n    avg_safety_score = EXCLUDED.avg_safety_score,\n    avg_comfort_score = EXCLUDED.avg_comfort_score,\n    avg_overall_score = EXCLUDED.avg_overall_score,\n    review_count = EXCLUDED.review_count,\n    last_review_date = EXCLUDED.last_review_date,\n    calculated_at = now();\n\n  -- Calculate RACE/ETHNICITY specific scores with vote weighting\n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'race_ethnicity', race_val,\n    (SUM(r.safety_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.comfort_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.overall_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id,\n  LATERAL unnest(up.race_ethnicity) AS race_val\n  WHERE r.location_id = p_location_id \n    AND r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL \n    AND array_length(up.race_ethnicity, 1) > 0\n    AND (1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2)) > 0\n  GROUP BY race_val\n  HAVING COUNT(*) > 0\n  ON CONFLICT (location_id, demographic_type, demographic_value) \n  DO UPDATE SET\n    avg_safety_score = EXCLUDED.avg_safety_score,\n    avg_comfort_score = EXCLUDED.avg_comfort_score,\n    avg_overall_score = EXCLUDED.avg_overall_score,\n    review_count = EXCLUDED.review_count,\n    last_review_date = EXCLUDED.last_review_date,\n    calculated_at = now();\n\n  -- Calculate GENDER specific scores with vote weighting\n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'gender', up.gender,\n    (SUM(r.safety_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.comfort_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    (SUM(r.overall_rating * GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)) / \n     SUM(GREATEST(1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2), 0.1)))::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  WHERE r.location_id = p_location_id \n    AND r.status = 'active'\n    AND up.gender IS NOT NULL \n    AND up.gender != ''\n    AND (1 + (COALESCE(r.helpful_count, 0) * 0.1) - (COALESCE(r.unhelpful_count, 0) * 0.2)) > 0\n  GROUP BY up.gender\n  HAVING COUNT(*) > 0\n  ON CONFLICT (location_id, demographic_type, demographic_value) \n  DO UPDATE SET\n    avg_safety_score = EXCLUDED.avg_safety_score,\n    avg_comfort_score = EXCLUDED.avg_comfort_score,\n    avg_overall_score = EXCLUDED.avg_overall_score,\n    review_count = EXCLUDED.review_count,\n    last_review_date = EXCLUDED.last_review_date,\n    calculated_at = now();\n\n  -- Update the locations table with overall scores\n  UPDATE locations \n  SET \n    avg_safety_score = (SELECT avg_safety_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    avg_comfort_score = (SELECT avg_comfort_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    avg_overall_score = (SELECT avg_overall_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    review_count = (SELECT review_count FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall')\n  WHERE id = p_location_id;\n\nEND;\n$function$\n"
  },
  {
    "function_name": "calculate_time_of_day",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.calculate_time_of_day(visit_time timestamp with time zone)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  hour INTEGER;\nBEGIN\n  hour := EXTRACT(HOUR FROM visit_time);\n  \n  IF hour >= 6 AND hour < 12 THEN\n    RETURN 'morning';\n  ELSIF hour >= 12 AND hour < 18 THEN\n    RETURN 'afternoon';\n  ELSIF hour >= 18 AND hour < 22 THEN\n    RETURN 'evening';\n  ELSE\n    RETURN 'night';\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_name": "cleanup_old_notification_logs",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_notification_logs()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  DELETE FROM notification_logs\n  WHERE sent_at < NOW() - INTERVAL '30 days';\nEND;\n$function$\n"
  },
  {
    "function_name": "cleanup_old_rate_limits",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_rate_limits()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  DELETE FROM website_signup_rate_limits\n  WHERE created_at < NOW() - INTERVAL '24 hours';\nEND;\n$function$\n"
  },
  {
    "function_name": "cleanup_search_history",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.cleanup_search_history()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  DELETE FROM public.search_history\n  WHERE id IN (\n    SELECT id FROM (\n      SELECT id, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY searched_at DESC) as rn\n      FROM public.search_history\n    ) ranked\n    WHERE rn > 100\n  );\nEND;\n$function$\n"
  },
  {
    "function_name": "decrement_prediction_vote_count",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.decrement_prediction_vote_count(p_location_id uuid, p_demographic_type text, p_demographic_value text, p_count_field text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF p_count_field = 'accurate_count' THEN\n    UPDATE safety_scores \n    SET accurate_count = GREATEST(accurate_count - 1, 0)\n    WHERE location_id = p_location_id\n      AND demographic_type = p_demographic_type\n      AND (demographic_value = p_demographic_value OR (demographic_value IS NULL AND p_demographic_value IS NULL));\n  ELSIF p_count_field = 'inaccurate_count' THEN\n    UPDATE safety_scores \n    SET inaccurate_count = GREATEST(inaccurate_count - 1, 0)\n    WHERE location_id = p_location_id\n      AND demographic_type = p_demographic_type\n      AND (demographic_value = p_demographic_value OR (demographic_value IS NULL AND p_demographic_value IS NULL));\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_name": "decrement_review_count",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.decrement_review_count(review_id uuid, count_field text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF count_field = 'helpful_count' THEN\n    UPDATE reviews SET helpful_count = GREATEST(helpful_count - 1, 0) WHERE id = review_id;\n  ELSIF count_field = 'unhelpful_count' THEN\n    UPDATE reviews SET unhelpful_count = GREATEST(unhelpful_count - 1, 0) WHERE id = review_id;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_name": "extract_ml_training_data",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.extract_ml_training_data()\n RETURNS TABLE(user_id uuid, location_id uuid, user_race_ethnicity text[], user_gender text, user_lgbtq_status boolean, user_religion text, user_age_range text, location_type text, location_latitude numeric, location_longitude numeric, safety_rating numeric, comfort_rating numeric, overall_rating numeric, review_created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.user_id,\n    r.location_id,\n    up.race_ethnicity,\n    up.gender,\n    up.lgbtq_status,\n    up.religion,\n    up.age_range,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as location_latitude,\n    ST_X(l.coordinates::geometry) as location_longitude,\n    r.safety_rating,\n    r.comfort_rating,\n    r.overall_rating,\n    r.created_at\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL \n    AND up.gender IS NOT NULL\n    AND up.gender != ''\n  ORDER BY r.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "find_similar_users",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.find_similar_users(target_user_id uuid, similarity_threshold numeric DEFAULT 0.6)\n RETURNS TABLE(similar_user_id uuid, similarity_score numeric, shared_demographics text[])\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH target_user AS (\n    SELECT race_ethnicity, gender, lgbtq_status, religion, age_range\n    FROM user_profiles \n    WHERE id = target_user_id\n  ),\n  user_similarities AS (\n    SELECT \n      up.id as similar_user_id,\n      CASE \n        WHEN up.id = target_user_id THEN 0  -- Exclude self\n        ELSE\n          -- Calculate similarity score (0-1)\n          (\n            -- Race/ethnicity overlap (40% weight)\n            CASE \n              WHEN up.race_ethnicity && tu.race_ethnicity THEN 0.4\n              ELSE 0 \n            END +\n            -- Gender match (20% weight)  \n            CASE \n              WHEN up.gender = tu.gender THEN 0.2\n              ELSE 0\n            END +\n            -- LGBTQ+ match (20% weight)\n            CASE \n              WHEN up.lgbtq_status = tu.lgbtq_status THEN 0.2\n              ELSE 0\n            END +\n            -- Religion match (10% weight)\n            CASE \n              WHEN up.religion = tu.religion THEN 0.1\n              ELSE 0\n            END +\n            -- Age range match (10% weight)\n            CASE \n              WHEN up.age_range = tu.age_range THEN 0.1\n              ELSE 0\n            END\n          )\n      END as similarity_score,\n      -- Track which demographics matched\n      ARRAY[\n        CASE WHEN up.race_ethnicity && tu.race_ethnicity THEN 'race' ELSE NULL END,\n        CASE WHEN up.gender = tu.gender THEN 'gender' ELSE NULL END,\n        CASE WHEN up.lgbtq_status = tu.lgbtq_status THEN 'lgbtq' ELSE NULL END,\n        CASE WHEN up.religion = tu.religion THEN 'religion' ELSE NULL END,\n        CASE WHEN up.age_range = tu.age_range THEN 'age' ELSE NULL END\n      ]::text[] as shared_demographics\n    FROM user_profiles up, target_user tu\n    WHERE up.id != target_user_id\n  )\n  SELECT \n    us.similar_user_id,\n    us.similarity_score,\n    array_remove(us.shared_demographics, NULL) as shared_demographics\n  FROM user_similarities us\n  WHERE us.similarity_score >= similarity_threshold\n  ORDER BY us.similarity_score DESC\n  LIMIT 10;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_basic_ml_recommendations",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_basic_ml_recommendations(target_user_id uuid, max_recommendations integer DEFAULT 5)\n RETURNS TABLE(location_id uuid, location_name text, predicted_safety_score numeric, confidence_score numeric, similar_user_count integer, recommendation_reason text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH target_user_demographics AS (\n    SELECT race_ethnicity, gender, lgbtq_status\n    FROM user_profiles \n    WHERE id = target_user_id\n  ),\n  similar_users AS (\n    -- Find users with overlapping demographics\n    SELECT \n      up.id as similar_user_id,\n      CASE \n        -- Calculate similarity score (0-1)\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.gender = tu.gender AND up.lgbtq_status = tu.lgbtq_status THEN 1.0  -- Perfect match\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.gender = tu.gender THEN 0.8  -- Race + gender match\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.lgbtq_status = tu.lgbtq_status THEN 0.7  -- Race + LGBTQ+ match\n        WHEN up.gender = tu.gender AND up.lgbtq_status = tu.lgbtq_status THEN 0.6  -- Gender + LGBTQ+ match\n        WHEN up.race_ethnicity && tu.race_ethnicity THEN 0.5  -- Race match only\n        WHEN up.gender = tu.gender THEN 0.4  -- Gender match only\n        WHEN up.lgbtq_status = tu.lgbtq_status THEN 0.3  -- LGBTQ+ match only\n        ELSE 0\n      END as similarity_score\n    FROM user_profiles up, target_user_demographics tu\n    WHERE up.id != target_user_id\n      AND up.race_ethnicity IS NOT NULL\n      AND up.gender IS NOT NULL\n  ),\n  user_location_scores AS (\n    -- Get ratings from similar users, excluding locations target user already reviewed\n    SELECT \n      r.location_id,\n      r.safety_rating,\n      r.overall_rating,\n      su.similarity_score,\n      su.similar_user_id\n    FROM reviews r\n    JOIN similar_users su ON r.user_id = su.similar_user_id\n    WHERE r.status = 'active'\n      AND su.similarity_score >= 0.3  -- Minimum similarity threshold\n      AND r.location_id NOT IN (\n        -- Exclude locations the target user has already reviewed\n        SELECT rev.location_id FROM reviews rev WHERE rev.user_id = target_user_id AND rev.status = 'active'\n      )\n  ),\n  location_predictions AS (\n    SELECT \n      uls.location_id,\n      -- Weighted average safety score based on user similarity\n      ROUND(\n        SUM(uls.safety_rating * uls.similarity_score) / \n        NULLIF(SUM(uls.similarity_score), 0), \n        2\n      ) as predicted_safety_score,\n      -- Confidence based on number of similar users and their similarity scores\n      LEAST(\n        ROUND(\n          (COUNT(DISTINCT uls.similar_user_id) * AVG(uls.similarity_score))::numeric, \n          2\n        ),\n        1.0\n      ) as confidence_score,\n      COUNT(DISTINCT uls.similar_user_id)::integer as similar_user_count,\n      CASE \n        WHEN COUNT(DISTINCT uls.similar_user_id) >= 3 THEN 'Highly recommended by users like you'\n        WHEN COUNT(DISTINCT uls.similar_user_id) = 2 THEN 'Recommended by similar users'  \n        ELSE 'Limited data from similar users'\n      END as recommendation_reason\n    FROM user_location_scores uls\n    GROUP BY uls.location_id\n    HAVING COUNT(DISTINCT uls.similar_user_id) >= 1  -- At least 1 similar user reviewed\n  )\n  SELECT \n    lp.location_id,\n    l.name as location_name,\n    lp.predicted_safety_score,\n    lp.confidence_score,\n    lp.similar_user_count,\n    lp.recommendation_reason\n  FROM location_predictions lp\n  JOIN locations l ON lp.location_id = l.id\n  WHERE l.active = true\n    AND lp.predicted_safety_score >= 3.0  -- Only recommend reasonably safe places\n  ORDER BY \n    lp.confidence_score DESC,\n    lp.predicted_safety_score DESC\n  LIMIT max_recommendations;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_discrimination_patterns",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_discrimination_patterns(p_location_id uuid DEFAULT NULL::uuid, p_threshold numeric DEFAULT 1.5)\n RETURNS TABLE(location_id uuid, location_name text, pattern_type text, severity text, affected_demographics text[], evidence jsonb, recommendation text)\n LANGUAGE sql\nAS $function$\n  -- Pattern 1: Demographic Disparity\n  SELECT \n    l.id,\n    l.name,\n    'demographic_disparity'::TEXT,\n    CASE \n      WHEN ABS(ss.avg_overall_score - overall.avg_overall_score) >= 3 THEN 'high'\n      WHEN ABS(ss.avg_overall_score - overall.avg_overall_score) >= 2 THEN 'medium'\n      ELSE 'low'\n    END::TEXT,\n    ARRAY[ss.demographic_type || ': ' || ss.demographic_value]::TEXT[],\n    jsonb_build_object(\n      'score_disparity', ROUND(ABS(ss.avg_overall_score - overall.avg_overall_score)::NUMERIC, 2),\n      'review_count', ss.review_count,\n      'specific_issues', ARRAY[\n        ss.demographic_type || ': ' || ss.demographic_value || ' rates this ' || ROUND(ss.avg_overall_score, 1) || '/5',\n        'Overall average is ' || ROUND(overall.avg_overall_score, 1) || '/5',\n        'Disparity of ' || ROUND(ABS(ss.avg_overall_score - overall.avg_overall_score), 1) || ' points'\n      ]\n    ),\n    CASE \n      WHEN ss.avg_overall_score < overall.avg_overall_score THEN\n        'Investigate why ' || ss.demographic_type || ': ' || ss.demographic_value || ' users feel less safe'\n      ELSE\n        'This location is particularly welcoming to ' || ss.demographic_type || ': ' || ss.demographic_value\n    END\n  FROM locations l\n  JOIN safety_scores ss ON ss.location_id = l.id\n  JOIN safety_scores overall ON overall.location_id = l.id AND overall.demographic_type = 'overall'\n  WHERE l.active = true\n    AND (p_location_id IS NULL OR l.id = p_location_id)\n    AND ss.demographic_type != 'overall'\n    AND ABS(ss.avg_overall_score - overall.avg_overall_score) >= p_threshold\n\n  UNION ALL\n\n  -- Pattern 2: Time-Based Discrimination\n  SELECT \n    l.id,\n    l.name,\n    'time_based_discrimination'::TEXT,\n    'high'::TEXT,\n    ARRAY_AGG(DISTINCT \n      CASE \n        WHEN r.content ILIKE '%night%' OR r.content ILIKE '%evening%' OR r.content ILIKE '%dark%' THEN\n          up.gender || ' users'\n        WHEN r.content ILIKE '%sundown%' OR r.content ILIKE '%sunset%' THEN\n          COALESCE(up.race_ethnicity[1], 'minority') || ' users'\n      END\n    )::TEXT[],\n    jsonb_build_object(\n      'review_count', COUNT(*),\n      'active_times', ARRAY['evening', 'night'],\n      'specific_issues', ARRAY_AGG(\n        SUBSTRING(r.content FROM '.{0,50}(night|evening|dark|sundown|sunset).{0,50}')\n      )\n    ),\n    'Location shows increased safety concerns during evening/night hours'\n  FROM locations l\n  JOIN reviews r ON r.location_id = l.id\n  JOIN user_profiles up ON up.id = r.user_id\n  WHERE l.active = true\n    AND (p_location_id IS NULL OR l.id = p_location_id)\n    AND r.status = 'active'\n    AND (r.safety_rating <= 2 OR r.comfort_rating <= 2)\n    AND (\n      r.content ILIKE '%night%' OR \n      r.content ILIKE '%evening%' OR \n      r.content ILIKE '%dark%' OR\n      r.content ILIKE '%sundown%' OR\n      r.content ILIKE '%sunset%' OR\n      r.content ILIKE '%after dark%'\n    )\n  GROUP BY l.id, l.name\n  HAVING COUNT(*) >= 2\n\n  UNION ALL\n\n  -- Pattern 3: Systematic Bias\n  SELECT \n    l.id,\n    l.name,\n    'systematic_bias'::TEXT,\n    'high'::TEXT,\n    ARRAY_AGG(DISTINCT \n      CASE \n        WHEN array_length(up.race_ethnicity, 1) > 0 THEN 'race: ' || up.race_ethnicity[1]\n        WHEN up.lgbtq_status = true THEN 'lgbtq: yes'\n        ELSE 'gender: ' || up.gender\n      END\n    )::TEXT[],\n    jsonb_build_object(\n      'review_count', COUNT(*),\n      'avg_rating', ROUND(AVG(r.overall_rating), 1),\n      'specific_issues', ARRAY[\n        'Consistent pattern of low ratings from specific demographic groups',\n        COUNT(*) || ' negative reviews from affected demographics',\n        'Average rating from affected groups: ' || ROUND(AVG(r.overall_rating), 1) || '/5'\n      ]\n    ),\n    'This location shows systematic bias against certain demographic groups'\n  FROM locations l\n  JOIN reviews r ON r.location_id = l.id\n  JOIN user_profiles up ON up.id = r.user_id\n  WHERE l.active = true\n    AND (p_location_id IS NULL OR l.id = p_location_id)\n    AND r.status = 'active'\n    AND r.overall_rating <= 2.5\n  GROUP BY l.id, l.name\n  HAVING COUNT(*) >= 3\n    AND AVG(r.overall_rating) <= 2.5\n\n  ORDER BY \n    1, -- location_id\n    3\n$function$\n"
  },
  {
    "function_name": "get_location_time_safety",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_location_time_safety(p_location_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_result JSON;\nBEGIN\n  SELECT json_build_object(\n    'morning', json_build_object(\n      'avg_safety', ROUND(AVG(CASE WHEN time_of_day = 'morning' THEN safety_rating END)::numeric, 1),\n      'review_count', COUNT(CASE WHEN time_of_day = 'morning' THEN 1 END)\n    ),\n    'afternoon', json_build_object(\n      'avg_safety', ROUND(AVG(CASE WHEN time_of_day = 'afternoon' THEN safety_rating END)::numeric, 1),\n      'review_count', COUNT(CASE WHEN time_of_day = 'afternoon' THEN 1 END)\n    ),\n    'evening', json_build_object(\n      'avg_safety', ROUND(AVG(CASE WHEN time_of_day = 'evening' THEN safety_rating END)::numeric, 1),\n      'review_count', COUNT(CASE WHEN time_of_day = 'evening' THEN 1 END)\n    ),\n    'night', json_build_object(\n      'avg_safety', ROUND(AVG(CASE WHEN time_of_day = 'night' THEN safety_rating END)::numeric, 1),\n      'review_count', COUNT(CASE WHEN time_of_day = 'night' THEN 1 END)\n    ),\n    'total_with_time', COUNT(time_of_day)\n  ) INTO v_result\n  FROM reviews\n  WHERE location_id = p_location_id\n    AND status = 'active';\n\n  RETURN v_result;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_location_with_coords",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_location_with_coords(location_id uuid)\n RETURNS TABLE(id uuid, name text, address text, city text, state_province text, country text, place_type text, latitude double precision, longitude double precision, avg_safety_score numeric, avg_comfort_score numeric, avg_overall_score numeric, review_count integer, verified boolean, active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.city,\n    l.state_province,\n    l.country,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude,\n    l.avg_safety_score,\n    l.avg_comfort_score,\n    l.avg_overall_score,\n    l.review_count,\n    l.verified,\n    l.active,\n    l.created_at,\n    l.updated_at\n  FROM locations l\n  WHERE l.id = location_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_ml_recommendations_for_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_ml_recommendations_for_user(target_user_id uuid, user_lat numeric DEFAULT NULL::numeric, user_lng numeric DEFAULT NULL::numeric, max_distance_meters integer DEFAULT 50000)\n RETURNS TABLE(location_id uuid, location_name text, predicted_safety_score numeric, confidence_score numeric, similar_user_count integer, recommendation_reason text, distance_meters integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH similar_users AS (\n    SELECT similar_user_id, similarity_score \n    FROM find_similar_users(target_user_id, 0.4)\n  ),\n  similar_user_reviews AS (\n    SELECT \n      r.location_id,\n      r.safety_rating,\n      r.overall_rating,\n      su.similarity_score,\n      COUNT(*) OVER (PARTITION BY r.location_id) as review_count\n    FROM reviews r\n    JOIN similar_users su ON r.user_id = su.similar_user_id\n    WHERE r.status = 'active'\n  ),\n  location_predictions AS (\n    SELECT \n      sur.location_id,\n      -- Weighted average safety score based on user similarity\n      ROUND(\n        SUM(sur.safety_rating * sur.similarity_score) / \n        SUM(sur.similarity_score), \n        2\n      ) as predicted_safety_score,\n      -- Confidence based on number of similar users and their similarity\n      LEAST(\n        ROUND(\n          (COUNT(DISTINCT sur.similarity_score) * AVG(sur.similarity_score))::numeric, \n          2\n        ),\n        1.0\n      ) as confidence_score,\n      COUNT(DISTINCT sur.similarity_score)::integer as similar_user_count,\n      CASE \n        WHEN COUNT(DISTINCT sur.similarity_score) >= 3 THEN 'Highly recommended by similar users'\n        WHEN COUNT(DISTINCT sur.similarity_score) = 2 THEN 'Recommended by similar users'  \n        ELSE 'Limited data from similar users'\n      END as recommendation_reason\n    FROM similar_user_reviews sur\n    GROUP BY sur.location_id\n    HAVING COUNT(DISTINCT sur.similarity_score) >= 1  -- At least 1 similar user reviewed\n  )\n  SELECT \n    lp.location_id,\n    l.name as location_name,\n    lp.predicted_safety_score,\n    lp.confidence_score,\n    lp.similar_user_count,\n    lp.recommendation_reason,\n    CASE \n      WHEN user_lat IS NOT NULL AND user_lng IS NOT NULL THEN\n        ROUND(ST_Distance(l.coordinates, ST_MakePoint(user_lng, user_lat)::geography))::integer\n      ELSE NULL\n    END as distance_meters\n  FROM location_predictions lp\n  JOIN locations l ON lp.location_id = l.id\n  WHERE l.active = true\n    AND (\n      user_lat IS NULL OR user_lng IS NULL OR\n      ST_DWithin(l.coordinates, ST_MakePoint(user_lng, user_lat)::geography, max_distance_meters)\n    )\n  ORDER BY \n    lp.confidence_score DESC,\n    lp.predicted_safety_score DESC,\n    distance_meters ASC NULLS LAST\n  LIMIT 10;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_nearby_locations",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_nearby_locations(lat double precision, lng double precision, radius_meters integer DEFAULT 5000)\n RETURNS TABLE(id uuid, name text, address text, place_type text, distance_meters integer, avg_safety_score numeric, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.place_type::text,\n    ROUND(ST_Distance(l.coordinates, ST_MakePoint(lng, lat)::geography))::INTEGER as distance_meters,\n    l.avg_safety_score,  -- Use the direct column\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE ST_DWithin(l.coordinates, ST_MakePoint(lng, lat)::geography, radius_meters)\n    AND l.active = true\n  ORDER BY distance_meters;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_nearby_locations_for_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_nearby_locations_for_user(lat double precision, lng double precision, user_race_ethnicity text[] DEFAULT NULL::text[], user_gender text DEFAULT NULL::text, user_lgbtq_status boolean DEFAULT NULL::boolean, radius_meters integer DEFAULT 5000)\n RETURNS TABLE(id uuid, name text, address text, place_type text, distance_meters integer, avg_safety_score numeric, demographic_safety_score numeric, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.place_type::text,\n    ROUND(ST_Distance(l.coordinates, ST_MakePoint(lng, lat)::geography))::INTEGER as distance_meters,\n    l.avg_safety_score,\n    COALESCE(\n      -- Try race-specific score first\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'race_ethnicity' \n         AND user_race_ethnicity IS NOT NULL \n         AND ss.demographic_value = ANY(user_race_ethnicity)\n       LIMIT 1),\n      -- Then gender-specific score\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'gender' \n         AND user_gender IS NOT NULL \n         AND ss.demographic_value = user_gender\n       LIMIT 1),\n      -- Fall back to overall score\n      l.avg_safety_score\n    ) as demographic_safety_score,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE ST_DWithin(l.coordinates, ST_MakePoint(lng, lat)::geography, radius_meters)\n    AND l.active = true\n  ORDER BY distance_meters;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_nearby_reviews",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_nearby_reviews(lat double precision, lng double precision, radius_meters integer DEFAULT 10000, review_limit integer DEFAULT 10)\n RETURNS TABLE(id uuid, user_id uuid, location_id uuid, title text, content text, safety_rating numeric, overall_rating numeric, created_at timestamp with time zone, location_name text, location_address text, location_latitude double precision, location_longitude double precision, distance_meters double precision, user_full_name text, user_show_demographics boolean, user_race_ethnicity text[], user_gender text, user_lgbtq_status boolean, user_disability_status text[], helpful_count integer, unhelpful_count integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.id,\n    r.user_id,\n    r.location_id,\n    r.title,\n    r.content,\n    r.safety_rating::numeric,\n    r.overall_rating::numeric,\n    r.created_at,\n    l.name as location_name,\n    l.address as location_address,\n    ST_Y(l.coordinates::geometry) as location_latitude,\n    ST_X(l.coordinates::geometry) as location_longitude,\n    ST_Distance(\n      l.coordinates::geography,\n      ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography\n    ) as distance_meters,\n    COALESCE(up.full_name, 'Anonymous') as user_full_name,\n    COALESCE(up.show_demographics, false) as user_show_demographics,\n    COALESCE(up.race_ethnicity, ARRAY[]::text[]) as user_race_ethnicity,\n    COALESCE(up.gender, '') as user_gender,\n    COALESCE(up.lgbtq_status, false) as user_lgbtq_status,\n    COALESCE(up.disability_status, ARRAY[]::text[]) as user_disability_status,\n    COALESCE(r.helpful_count, 0) as helpful_count,\n    COALESCE(r.unhelpful_count, 0) as unhelpful_count\n  FROM reviews r\n  JOIN locations l ON r.location_id = l.id\n  LEFT JOIN user_profiles up ON r.user_id = up.id\n  WHERE \n    r.status = 'active'\n    AND ST_DWithin(\n      l.coordinates::geography,\n      ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography,\n      radius_meters\n    )\n  ORDER BY r.created_at DESC\n  LIMIT review_limit;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_neighborhood_stats",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_neighborhood_stats(p_latitude numeric, p_longitude numeric, p_radius_meters integer DEFAULT 500)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_result JSON;\nBEGIN\n  -- Find the census block group that contains this point\n  SELECT json_build_object(\n    'block_group_fips', ns.block_group_fips,\n    'name', ns.name,\n    'city', ns.city,\n    'county_name', ns.county_name,\n    'state_code', ns.state_code,\n    'population', ns.population,\n    'diversity_index', ns.diversity_index,\n    'pct_minority', ns.pct_minority,\n    'crime_rate_per_1000', ns.crime_rate_per_1000,\n    'violent_crime_rate', ns.violent_crime_rate,\n    'property_crime_rate', ns.property_crime_rate,\n    'hate_crime_incidents', ns.hate_crime_incidents,\n    'walkability_score', ns.walkability_score,\n    'data_source', ns.data_source,\n    'data_year', ns.data_year\n  ) INTO v_result\n  FROM neighborhood_stats ns\n  WHERE ST_Contains(\n    ns.boundary::geometry,\n    ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326)\n  )\n  LIMIT 1;\n\n  RETURN v_result;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_neighborhood_stats_for_point",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_neighborhood_stats_for_point(lat double precision, lng double precision)\n RETURNS TABLE(block_group_fips character, name text, city text, state_code character, population integer, crime_rate_per_1000 numeric, violent_crime_rate numeric, property_crime_rate numeric, hate_crime_incidents integer, diversity_index numeric, pct_minority numeric, walkability_score integer, police_response_min numeric, data_source text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ns.block_group_fips,\n    ns.name,\n    ns.city,\n    ns.state_code,\n    ns.population,\n    ns.crime_rate_per_1000,\n    ns.violent_crime_rate,\n    ns.property_crime_rate,\n    ns.hate_crime_incidents,\n    ns.diversity_index,\n    ns.pct_minority,\n    ns.walkability_score,\n    ns.police_response_min,\n    ns.data_source\n  FROM neighborhood_stats ns\n  WHERE ST_Contains(ns.boundary::geometry, ST_SetSRID(ST_MakePoint(lng, lat), 4326))\n  LIMIT 1;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_safety_insights",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_safety_insights(user_lat double precision DEFAULT NULL::double precision, user_lng double precision DEFAULT NULL::double precision, radius_meters integer DEFAULT 50000, max_results integer DEFAULT 5)\n RETURNS TABLE(insight_type text, message text, location_id uuid, location_name text, location_address text, severity text, created_at timestamp with time zone, change_value numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  \n  -- 1. RATING DROPS: Locations with significant safety rating decreases\n  WITH recent_reviews AS (\n    SELECT \n      r.location_id,\n      AVG(r.safety_rating) as recent_avg,\n      COUNT(*) as recent_count\n    FROM reviews r\n    WHERE r.status = 'active'\n      AND r.created_at >= NOW() - INTERVAL '7 days'\n    GROUP BY r.location_id\n    HAVING COUNT(*) >= 2\n  ),\n  older_reviews AS (\n    SELECT \n      r.location_id,\n      AVG(r.safety_rating) as older_avg\n    FROM reviews r\n    WHERE r.status = 'active'\n      AND r.created_at < NOW() - INTERVAL '7 days'\n      AND r.created_at >= NOW() - INTERVAL '30 days'\n    GROUP BY r.location_id\n    HAVING COUNT(*) >= 2\n  ),\n  rating_drops AS (\n    SELECT \n      l.id as location_id,\n      l.name as location_name,\n      l.address as location_address,\n      'rating_drop' as insight_type,\n      'âš ï¸ Safety concerns reported at ' || l.name as message,\n      'high' as severity,\n      MAX(r.created_at) as created_at,\n      ROUND(rr.recent_avg - orr.older_avg, 1) as change_value\n    FROM locations l\n    JOIN recent_reviews rr ON l.id = rr.location_id\n    JOIN older_reviews orr ON l.id = orr.location_id\n    LEFT JOIN reviews r ON l.id = r.location_id AND r.created_at >= NOW() - INTERVAL '7 days'\n    WHERE l.active = true\n      AND (rr.recent_avg - orr.older_avg) <= -1.0\n      AND (user_lat IS NULL OR ST_DWithin(\n        l.coordinates, \n        ST_MakePoint(user_lng, user_lat)::geography, \n        radius_meters\n      ))\n    GROUP BY l.id, l.name, l.address, rr.recent_avg, orr.older_avg\n  ),\n  \n  -- 2. RATING IMPROVEMENTS: Locations getting safer\n  rating_improvements AS (\n    SELECT \n      l.id as location_id,\n      l.name as location_name,\n      l.address as location_address,\n      'rating_improve' as insight_type,\n      'ðŸ“ˆ Safety improving at ' || l.name as message,\n      'low' as severity,\n      MAX(r.created_at) as created_at,\n      ROUND(rr.recent_avg - orr.older_avg, 1) as change_value\n    FROM locations l\n    JOIN recent_reviews rr ON l.id = rr.location_id\n    JOIN older_reviews orr ON l.id = orr.location_id\n    LEFT JOIN reviews r ON l.id = r.location_id AND r.created_at >= NOW() - INTERVAL '7 days'\n    WHERE l.active = true\n      AND (rr.recent_avg - orr.older_avg) >= 0.5\n      AND (user_lat IS NULL OR ST_DWithin(\n        l.coordinates, \n        ST_MakePoint(user_lng, user_lat)::geography, \n        radius_meters\n      ))\n    GROUP BY l.id, l.name, l.address, rr.recent_avg, orr.older_avg\n  ),\n  \n  -- 3. HIGH ACTIVITY: Locations with sudden review spikes\n  high_activity AS (\n    SELECT \n      l.id as location_id,\n      l.name as location_name,\n      l.address as location_address,\n      'high_activity' as insight_type,\n      'ðŸ”¥ ' || l.name || ' receiving high attention (' || COUNT(r.id)::text || ' new reviews)' as message,\n      'medium' as severity,\n      MAX(r.created_at) as created_at,\n      COUNT(r.id)::numeric as change_value\n    FROM locations l\n    JOIN reviews r ON l.id = r.location_id\n    WHERE l.active = true\n      AND r.status = 'active'\n      AND r.created_at >= NOW() - INTERVAL '7 days'\n      AND (user_lat IS NULL OR ST_DWithin(\n        l.coordinates, \n        ST_MakePoint(user_lng, user_lat)::geography, \n        radius_meters\n      ))\n    GROUP BY l.id, l.name, l.address\n    HAVING COUNT(r.id) >= 5\n  ),\n  \n  -- 4. CONSISTENTLY SAFE: Locations maintaining excellent ratings\n  consistently_safe AS (\n    SELECT \n      l.id as location_id,\n      l.name as location_name,\n      l.address as location_address,\n      'consistently_safe' as insight_type,\n      'âœ… ' || l.name || ' consistently rated safe' as message,\n      'low' as severity,\n      MAX(r.created_at) as created_at,\n      ROUND(AVG(r.safety_rating), 1) as change_value\n    FROM locations l\n    JOIN reviews r ON l.id = r.location_id\n    WHERE l.active = true\n      AND r.status = 'active'\n      AND r.created_at >= NOW() - INTERVAL '30 days'\n      AND (user_lat IS NULL OR ST_DWithin(\n        l.coordinates, \n        ST_MakePoint(user_lng, user_lat)::geography, \n        radius_meters\n      ))\n    GROUP BY l.id, l.name, l.address\n    HAVING COUNT(r.id) >= 5 AND AVG(r.safety_rating) >= 4.5\n  ),\n  \n  -- Combine all insights with proper CTE\n  all_insights AS (\n    SELECT * FROM rating_drops\n    UNION ALL\n    SELECT * FROM rating_improvements\n    UNION ALL\n    SELECT * FROM high_activity\n    UNION ALL\n    SELECT * FROM consistently_safe\n  )\n  \n  SELECT \n    all_insights.insight_type,\n    all_insights.message,\n    all_insights.location_id,\n    all_insights.location_name,\n    all_insights.location_address,\n    all_insights.severity,\n    all_insights.created_at,\n    all_insights.change_value\n  FROM all_insights\n  ORDER BY \n    CASE all_insights.severity \n      WHEN 'high' THEN 1\n      WHEN 'medium' THEN 2\n      WHEN 'low' THEN 3\n    END,\n    all_insights.created_at DESC\n  LIMIT max_results;\n  \nEND;\n$function$\n"
  },
  {
    "function_name": "get_trending_locations",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_trending_locations(days_window integer DEFAULT 7, max_results integer DEFAULT 5)\n RETURNS TABLE(location_id uuid, location_name text, location_address text, review_count_current integer, review_count_previous integer, trend_direction text, trend_percentage numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH current_period AS (\n    SELECT \n      r.location_id,\n      COUNT(*)::integer as review_count\n    FROM reviews r\n    WHERE r.status = 'active'\n      AND r.created_at >= NOW() - (days_window || ' days')::INTERVAL\n    GROUP BY r.location_id\n  ),\n  previous_period AS (\n    SELECT \n      r.location_id,\n      COUNT(*)::integer as review_count\n    FROM reviews r\n    WHERE r.status = 'active'\n      AND r.created_at >= NOW() - (days_window * 2 || ' days')::INTERVAL\n      AND r.created_at < NOW() - (days_window || ' days')::INTERVAL\n    GROUP BY r.location_id\n  )\n  SELECT \n    l.id as location_id,\n    l.name as location_name,\n    l.address as location_address,\n    COALESCE(cp.review_count, 0)::integer as review_count_current,\n    COALESCE(pp.review_count, 0)::integer as review_count_previous,\n    'up' as trend_direction,\n    CASE \n      WHEN COALESCE(pp.review_count, 0) = 0 THEN 100.0\n      ELSE ROUND(\n        ((COALESCE(cp.review_count, 0) - COALESCE(pp.review_count, 0))::NUMERIC / \n        NULLIF(COALESCE(pp.review_count, 0), 0)::NUMERIC) * 100, \n        1\n      )\n    END as trend_percentage\n  FROM locations l\n  INNER JOIN current_period cp ON l.id = cp.location_id\n  LEFT JOIN previous_period pp ON l.id = pp.location_id\n  WHERE l.active = true\n    -- Must have meaningful activity this period\n    AND cp.review_count >= 2\n    -- Must show growth (more reviews than last period)\n    AND cp.review_count > COALESCE(pp.review_count, 0)\n    -- Must have significant growth (at least 50% increase OR went from 0 to multiple reviews)\n    AND (\n      COALESCE(pp.review_count, 0) = 0 -- New buzz (0 to multiple reviews)\n      OR (\n        (cp.review_count - COALESCE(pp.review_count, 0))::NUMERIC / \n        NULLIF(COALESCE(pp.review_count, 0), 0)::NUMERIC >= 0.5 -- 50%+ growth\n      )\n    )\n  ORDER BY \n    -- Prioritize percentage growth, then absolute growth\n    trend_percentage DESC,\n    (cp.review_count - COALESCE(pp.review_count, 0)) DESC\n  LIMIT max_results;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_activity_stats",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_user_activity_stats(p_user_id uuid)\n RETURNS TABLE(review_count integer, route_count integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    (\n      SELECT COUNT(*)::integer \n      FROM reviews r \n      WHERE r.user_id = p_user_id \n        AND r.status = 'active'\n    ) as review_count,\n    (\n      SELECT COUNT(*)::integer \n      FROM routes rt \n      WHERE rt.user_id = p_user_id\n    ) as route_count;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_public_profile",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_user_public_profile(profile_user_id uuid)\n RETURNS TABLE(user_id uuid, full_name text, avatar_url text, race_ethnicity text[], gender text, lgbtq_status boolean, disability_status text[], religion text, age_range text, privacy_level text, show_demographics boolean, total_reviews integer, created_at timestamp with time zone, is_public boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    up.id as user_id,\n    up.full_name,\n    up.avatar_url,\n    up.race_ethnicity,\n    up.gender,\n    up.lgbtq_status,\n    up.disability_status,\n    up.religion,\n    up.age_range,\n    up.privacy_level,\n    up.show_demographics,\n    up.total_reviews,\n    up.created_at,\n    (up.privacy_level = 'public') as is_public\n  FROM user_profiles up\n  WHERE up.id = profile_user_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_public_reviews",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_user_public_reviews(profile_user_id uuid, review_limit integer DEFAULT 10)\n RETURNS TABLE(id uuid, location_id uuid, location_name text, location_address text, overall_rating numeric, safety_rating numeric, title text, content text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.id,\n    r.location_id,\n    l.name as location_name,\n    l.address as location_address,\n    r.overall_rating::numeric,\n    r.safety_rating::numeric,\n    r.title,\n    r.content,\n    r.created_at\n  FROM reviews r\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.user_id = profile_user_id\n    AND r.status = 'active'\n  ORDER BY r.created_at DESC\n  LIMIT review_limit;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_vote_stats",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_user_vote_stats(p_user_id uuid)\n RETURNS TABLE(helpful_votes_given integer, unhelpful_votes_given integer, total_votes_given integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    COUNT(*) FILTER (WHERE vote_type = 'helpful')::integer as helpful_votes_given,\n    COUNT(*) FILTER (WHERE vote_type = 'unhelpful')::integer as unhelpful_votes_given,\n    COUNT(*)::integer as total_votes_given\n  FROM review_votes\n  WHERE user_id = p_user_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.profiles (user_id, onboarding_complete, demographics)\n  VALUES (NEW.id, false, '{}'::jsonb)\n  ON CONFLICT (user_id) DO NOTHING;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "increment_prediction_vote_count",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.increment_prediction_vote_count(p_location_id uuid, p_demographic_type text, p_demographic_value text, p_count_field text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF p_count_field = 'accurate_count' THEN\n    UPDATE safety_scores \n    SET accurate_count = accurate_count + 1 \n    WHERE location_id = p_location_id \n      AND demographic_type = p_demographic_type\n      AND (demographic_value = p_demographic_value OR (demographic_value IS NULL AND p_demographic_value IS NULL));\n  ELSIF p_count_field = 'inaccurate_count' THEN\n    UPDATE safety_scores \n    SET inaccurate_count = inaccurate_count + 1 \n    WHERE location_id = p_location_id \n      AND demographic_type = p_demographic_type\n      AND (demographic_value = p_demographic_value OR (demographic_value IS NULL AND p_demographic_value IS NULL));\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_name": "increment_review_count",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.increment_review_count(review_id uuid, count_field text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF count_field = 'helpful_count' THEN\n    UPDATE reviews SET helpful_count = helpful_count + 1 WHERE id = review_id;\n  ELSIF count_field = 'unhelpful_count' THEN\n    UPDATE reviews SET unhelpful_count = unhelpful_count + 1 WHERE id = review_id;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_name": "search_locations_with_coords",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.search_locations_with_coords(search_query text, result_limit integer DEFAULT 5)\n RETURNS TABLE(id uuid, name text, address text, city text, state_province text, place_type text, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.city,\n    l.state_province,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE (\n    l.name ILIKE '%' || search_query || '%' OR\n    l.address ILIKE '%' || search_query || '%' OR\n    l.city ILIKE '%' || search_query || '%'\n  )\n    AND l.active = true\n  ORDER BY \n    -- Prioritize name matches over address matches\n    CASE \n      WHEN l.name ILIKE '%' || search_query || '%' THEN 1\n      ELSE 2\n    END,\n    l.name\n  LIMIT result_limit;\nEND;\n$function$\n"
  },
  {
    "function_name": "set_time_of_day",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.set_time_of_day()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF NEW.visited_at IS NOT NULL THEN\n    NEW.time_of_day := calculate_time_of_day(NEW.visited_at);\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "test_demographic_patterns",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.test_demographic_patterns()\n RETURNS TABLE(pattern_type text, pattern_value text, user_count bigint, avg_safety_rating numeric, sample_locations text[])\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Race/ethnicity patterns\n  RETURN QUERY\n  SELECT \n    'race_ethnicity' as pattern_type,\n    race_val as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id,\n  LATERAL unnest(up.race_ethnicity) AS race_val\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL\n  GROUP BY race_val\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\n\n  -- Gender patterns  \n  RETURN QUERY\n  SELECT \n    'gender' as pattern_type,\n    up.gender as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.gender IS NOT NULL \n    AND up.gender != ''\n  GROUP BY up.gender\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\n\n  -- LGBTQ+ patterns\n  RETURN QUERY\n  SELECT \n    'lgbtq_status' as pattern_type,\n    CASE WHEN up.lgbtq_status THEN 'LGBTQ+' ELSE 'Non-LGBTQ+' END as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n  GROUP BY up.lgbtq_status\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\nEND;\n$function$\n"
  },
  {
    "function_name": "test_extract_ml_data",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.test_extract_ml_data()\n RETURNS TABLE(user_id uuid, location_id uuid, user_race_ethnicity text[], user_gender text, user_lgbtq_status boolean, location_name text, location_type text, safety_rating numeric, overall_rating numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.user_id,\n    r.location_id,\n    up.race_ethnicity,\n    up.gender,\n    up.lgbtq_status,\n    l.name as location_name,\n    l.place_type::text as location_type,\n    r.safety_rating::numeric,  -- Explicit cast to numeric\n    r.overall_rating::numeric  -- Explicit cast to numeric\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL \n    AND up.gender IS NOT NULL\n    AND up.gender != ''\n  ORDER BY r.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "trigger_calculate_safety_scores",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.trigger_calculate_safety_scores()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Add logging\n  RAISE NOTICE 'Trigger fired for location_id: %', NEW.location_id;\n  \n  -- Call the existing safety score calculation function\n  PERFORM calculate_location_safety_scores(NEW.location_id);\n  \n  RAISE NOTICE 'Safety scores calculated for location_id: %', NEW.location_id;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "update_updated_at_column",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "update_user_review_count",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.update_user_review_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    -- Increment count when review is created\n    UPDATE user_profiles \n    SET total_reviews = total_reviews + 1 \n    WHERE id = NEW.user_id;\n  ELSIF TG_OP = 'DELETE' THEN\n    -- Decrement count when review is deleted\n    UPDATE user_profiles \n    SET total_reviews = GREATEST(total_reviews - 1, 0) \n    WHERE id = OLD.user_id;\n  END IF;\n  RETURN NULL;\nEND;\n$function$\n"
  }
]
