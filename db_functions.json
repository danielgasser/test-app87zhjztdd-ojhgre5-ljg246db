[
  {
    "function_name": "calculate_location_safety_scores",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.calculate_location_safety_scores(p_location_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Delete existing scores for this location\n  DELETE FROM safety_scores WHERE location_id = p_location_id;\n  \n  -- Calculate OVERALL scores (all users combined)\n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'overall', null,\n    AVG(r.safety_rating)::numeric,\n    AVG(r.comfort_rating)::numeric, \n    AVG(r.overall_rating)::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  WHERE r.location_id = p_location_id AND r.status = 'active'\n  HAVING COUNT(*) > 0;\n\n  -- Calculate RACE/ETHNICITY specific scores\n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'race_ethnicity', race_val,\n    AVG(r.safety_rating)::numeric,\n    AVG(r.comfort_rating)::numeric,\n    AVG(r.overall_rating)::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id,\n  LATERAL unnest(up.race_ethnicity) AS race_val\n  WHERE r.location_id = p_location_id AND r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL AND array_length(up.race_ethnicity, 1) > 0\n  GROUP BY race_val\n  HAVING COUNT(*) > 0;\n\n  -- Calculate GENDER specific scores  \n  INSERT INTO safety_scores (\n    location_id, demographic_type, demographic_value,\n    avg_safety_score, avg_comfort_score, avg_overall_score, review_count, last_review_date\n  )\n  SELECT \n    p_location_id, 'gender', up.gender,\n    AVG(r.safety_rating)::numeric,\n    AVG(r.comfort_rating)::numeric,\n    AVG(r.overall_rating)::numeric,\n    COUNT(*)::integer,\n    MAX(r.created_at)\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  WHERE r.location_id = p_location_id AND r.status = 'active'\n    AND up.gender IS NOT NULL AND up.gender != ''\n  GROUP BY up.gender\n  HAVING COUNT(*) > 0;\n\n  -- Update the locations table with overall scores\n  UPDATE locations \n  SET \n    avg_safety_score = (SELECT avg_safety_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    avg_comfort_score = (SELECT avg_comfort_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    avg_overall_score = (SELECT avg_overall_score FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall'),\n    review_count = (SELECT review_count FROM safety_scores WHERE location_id = p_location_id AND demographic_type = 'overall')\n  WHERE id = p_location_id;\n\nEND;\n$function$\n"
  },
  {
    "function_name": "extract_ml_training_data",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.extract_ml_training_data()\n RETURNS TABLE(user_id uuid, location_id uuid, user_race_ethnicity text[], user_gender text, user_lgbtq_status boolean, user_religion text, user_age_range text, location_type text, location_latitude numeric, location_longitude numeric, safety_rating numeric, comfort_rating numeric, overall_rating numeric, review_created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.user_id,\n    r.location_id,\n    up.race_ethnicity,\n    up.gender,\n    up.lgbtq_status,\n    up.religion,\n    up.age_range,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as location_latitude,\n    ST_X(l.coordinates::geometry) as location_longitude,\n    r.safety_rating,\n    r.comfort_rating,\n    r.overall_rating,\n    r.created_at\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL \n    AND up.gender IS NOT NULL\n    AND up.gender != ''\n  ORDER BY r.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "find_similar_users",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.find_similar_users(target_user_id uuid, similarity_threshold numeric DEFAULT 0.6)\n RETURNS TABLE(similar_user_id uuid, similarity_score numeric, shared_demographics text[])\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH target_user AS (\n    SELECT race_ethnicity, gender, lgbtq_status, religion, age_range\n    FROM user_profiles \n    WHERE id = target_user_id\n  ),\n  user_similarities AS (\n    SELECT \n      up.id as similar_user_id,\n      CASE \n        WHEN up.id = target_user_id THEN 0  -- Exclude self\n        ELSE\n          -- Calculate similarity score (0-1)\n          (\n            -- Race/ethnicity overlap (40% weight)\n            CASE \n              WHEN up.race_ethnicity && tu.race_ethnicity THEN 0.4\n              ELSE 0 \n            END +\n            -- Gender match (20% weight)  \n            CASE \n              WHEN up.gender = tu.gender THEN 0.2\n              ELSE 0\n            END +\n            -- LGBTQ+ match (20% weight)\n            CASE \n              WHEN up.lgbtq_status = tu.lgbtq_status THEN 0.2\n              ELSE 0\n            END +\n            -- Religion match (10% weight)\n            CASE \n              WHEN up.religion = tu.religion THEN 0.1\n              ELSE 0\n            END +\n            -- Age range match (10% weight)\n            CASE \n              WHEN up.age_range = tu.age_range THEN 0.1\n              ELSE 0\n            END\n          )\n      END as similarity_score,\n      -- Track which demographics matched\n      ARRAY[\n        CASE WHEN up.race_ethnicity && tu.race_ethnicity THEN 'race' ELSE NULL END,\n        CASE WHEN up.gender = tu.gender THEN 'gender' ELSE NULL END,\n        CASE WHEN up.lgbtq_status = tu.lgbtq_status THEN 'lgbtq' ELSE NULL END,\n        CASE WHEN up.religion = tu.religion THEN 'religion' ELSE NULL END,\n        CASE WHEN up.age_range = tu.age_range THEN 'age' ELSE NULL END\n      ]::text[] as shared_demographics\n    FROM user_profiles up, target_user tu\n    WHERE up.id != target_user_id\n  )\n  SELECT \n    us.similar_user_id,\n    us.similarity_score,\n    array_remove(us.shared_demographics, NULL) as shared_demographics\n  FROM user_similarities us\n  WHERE us.similarity_score >= similarity_threshold\n  ORDER BY us.similarity_score DESC\n  LIMIT 10;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_basic_ml_recommendations",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_basic_ml_recommendations(target_user_id uuid, max_recommendations integer DEFAULT 5)\n RETURNS TABLE(location_id uuid, location_name text, predicted_safety_score numeric, confidence_score numeric, similar_user_count integer, recommendation_reason text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH target_user_demographics AS (\n    SELECT race_ethnicity, gender, lgbtq_status\n    FROM user_profiles \n    WHERE id = target_user_id\n  ),\n  similar_users AS (\n    -- Find users with overlapping demographics\n    SELECT \n      up.id as similar_user_id,\n      CASE \n        -- Calculate similarity score (0-1)\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.gender = tu.gender AND up.lgbtq_status = tu.lgbtq_status THEN 1.0  -- Perfect match\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.gender = tu.gender THEN 0.8  -- Race + gender match\n        WHEN up.race_ethnicity && tu.race_ethnicity AND up.lgbtq_status = tu.lgbtq_status THEN 0.7  -- Race + LGBTQ+ match\n        WHEN up.gender = tu.gender AND up.lgbtq_status = tu.lgbtq_status THEN 0.6  -- Gender + LGBTQ+ match\n        WHEN up.race_ethnicity && tu.race_ethnicity THEN 0.5  -- Race match only\n        WHEN up.gender = tu.gender THEN 0.4  -- Gender match only\n        WHEN up.lgbtq_status = tu.lgbtq_status THEN 0.3  -- LGBTQ+ match only\n        ELSE 0\n      END as similarity_score\n    FROM user_profiles up, target_user_demographics tu\n    WHERE up.id != target_user_id\n      AND up.race_ethnicity IS NOT NULL\n      AND up.gender IS NOT NULL\n  ),\n  user_location_scores AS (\n    -- Get ratings from similar users, excluding locations target user already reviewed\n    SELECT \n      r.location_id,\n      r.safety_rating,\n      r.overall_rating,\n      su.similarity_score,\n      su.similar_user_id\n    FROM reviews r\n    JOIN similar_users su ON r.user_id = su.similar_user_id\n    WHERE r.status = 'active'\n      AND su.similarity_score >= 0.3  -- Minimum similarity threshold\n      AND r.location_id NOT IN (\n        -- Exclude locations the target user has already reviewed\n        SELECT rev.location_id FROM reviews rev WHERE rev.user_id = target_user_id AND rev.status = 'active'\n      )\n  ),\n  location_predictions AS (\n    SELECT \n      uls.location_id,\n      -- Weighted average safety score based on user similarity\n      ROUND(\n        SUM(uls.safety_rating * uls.similarity_score) / \n        NULLIF(SUM(uls.similarity_score), 0), \n        2\n      ) as predicted_safety_score,\n      -- Confidence based on number of similar users and their similarity scores\n      LEAST(\n        ROUND(\n          (COUNT(DISTINCT uls.similar_user_id) * AVG(uls.similarity_score))::numeric, \n          2\n        ),\n        1.0\n      ) as confidence_score,\n      COUNT(DISTINCT uls.similar_user_id)::integer as similar_user_count,\n      CASE \n        WHEN COUNT(DISTINCT uls.similar_user_id) >= 3 THEN 'Highly recommended by users like you'\n        WHEN COUNT(DISTINCT uls.similar_user_id) = 2 THEN 'Recommended by similar users'  \n        ELSE 'Limited data from similar users'\n      END as recommendation_reason\n    FROM user_location_scores uls\n    GROUP BY uls.location_id\n    HAVING COUNT(DISTINCT uls.similar_user_id) >= 1  -- At least 1 similar user reviewed\n  )\n  SELECT \n    lp.location_id,\n    l.name as location_name,\n    lp.predicted_safety_score,\n    lp.confidence_score,\n    lp.similar_user_count,\n    lp.recommendation_reason\n  FROM location_predictions lp\n  JOIN locations l ON lp.location_id = l.id\n  WHERE l.active = true\n    AND lp.predicted_safety_score >= 3.0  -- Only recommend reasonably safe places\n  ORDER BY \n    lp.confidence_score DESC,\n    lp.predicted_safety_score DESC\n  LIMIT max_recommendations;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_heatmap_data",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_heatmap_data(center_lat double precision, center_lng double precision, radius_meters integer DEFAULT 10000, user_race_ethnicity text[] DEFAULT NULL::text[], user_gender text DEFAULT NULL::text, user_lgbtq_status boolean DEFAULT NULL::boolean, user_disability_status text[] DEFAULT NULL::text[], user_religion text DEFAULT NULL::text, user_age_range text DEFAULT NULL::text)\n RETURNS TABLE(latitude double precision, longitude double precision, safety_score numeric, review_count integer, heat_weight numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude,\n    COALESCE(\n      -- Try race-specific score first\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'race_ethnicity' \n         AND user_race_ethnicity IS NOT NULL \n         AND ss.demographic_value = ANY(user_race_ethnicity)\n       LIMIT 1),\n      -- Then gender-specific score\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'gender' \n         AND user_gender IS NOT NULL \n         AND ss.demographic_value = user_gender\n       LIMIT 1),\n      -- Fall back to overall score\n      l.avg_safety_score,\n      3.0  -- Default neutral score\n    ) as safety_score,\n    l.review_count::INTEGER as review_count,\n    COALESCE(\n      -- Same logic for heat weight\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'race_ethnicity' \n         AND user_race_ethnicity IS NOT NULL \n         AND ss.demographic_value = ANY(user_race_ethnicity)\n       LIMIT 1),\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'gender' \n         AND user_gender IS NOT NULL \n         AND ss.demographic_value = user_gender\n       LIMIT 1),\n      l.avg_safety_score,\n      3.0\n    ) as heat_weight\n  FROM locations l\n  WHERE ST_DWithin(l.coordinates, ST_MakePoint(center_lng, center_lat)::geography, radius_meters)\n    AND l.active = true\n    AND l.review_count > 0  -- Only include locations with reviews for heat map\n  ORDER BY review_count DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_location_with_coords",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_location_with_coords(location_id uuid)\n RETURNS TABLE(id uuid, name text, address text, city text, state_province text, country text, place_type text, latitude double precision, longitude double precision, avg_safety_score numeric, avg_comfort_score numeric, avg_overall_score numeric, review_count integer, verified boolean, active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.city,\n    l.state_province,\n    l.country,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude,\n    l.avg_safety_score,\n    l.avg_comfort_score,\n    l.avg_overall_score,\n    l.review_count,\n    l.verified,\n    l.active,\n    l.created_at,\n    l.updated_at\n  FROM locations l\n  WHERE l.id = location_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_ml_recommendations_for_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_ml_recommendations_for_user(target_user_id uuid, user_lat numeric DEFAULT NULL::numeric, user_lng numeric DEFAULT NULL::numeric, max_distance_meters integer DEFAULT 50000)\n RETURNS TABLE(location_id uuid, location_name text, predicted_safety_score numeric, confidence_score numeric, similar_user_count integer, recommendation_reason text, distance_meters integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH similar_users AS (\n    SELECT similar_user_id, similarity_score \n    FROM find_similar_users(target_user_id, 0.4)\n  ),\n  similar_user_reviews AS (\n    SELECT \n      r.location_id,\n      r.safety_rating,\n      r.overall_rating,\n      su.similarity_score,\n      COUNT(*) OVER (PARTITION BY r.location_id) as review_count\n    FROM reviews r\n    JOIN similar_users su ON r.user_id = su.similar_user_id\n    WHERE r.status = 'active'\n  ),\n  location_predictions AS (\n    SELECT \n      sur.location_id,\n      -- Weighted average safety score based on user similarity\n      ROUND(\n        SUM(sur.safety_rating * sur.similarity_score) / \n        SUM(sur.similarity_score), \n        2\n      ) as predicted_safety_score,\n      -- Confidence based on number of similar users and their similarity\n      LEAST(\n        ROUND(\n          (COUNT(DISTINCT sur.similarity_score) * AVG(sur.similarity_score))::numeric, \n          2\n        ),\n        1.0\n      ) as confidence_score,\n      COUNT(DISTINCT sur.similarity_score)::integer as similar_user_count,\n      CASE \n        WHEN COUNT(DISTINCT sur.similarity_score) >= 3 THEN 'Highly recommended by similar users'\n        WHEN COUNT(DISTINCT sur.similarity_score) = 2 THEN 'Recommended by similar users'  \n        ELSE 'Limited data from similar users'\n      END as recommendation_reason\n    FROM similar_user_reviews sur\n    GROUP BY sur.location_id\n    HAVING COUNT(DISTINCT sur.similarity_score) >= 1  -- At least 1 similar user reviewed\n  )\n  SELECT \n    lp.location_id,\n    l.name as location_name,\n    lp.predicted_safety_score,\n    lp.confidence_score,\n    lp.similar_user_count,\n    lp.recommendation_reason,\n    CASE \n      WHEN user_lat IS NOT NULL AND user_lng IS NOT NULL THEN\n        ROUND(ST_Distance(l.coordinates, ST_MakePoint(user_lng, user_lat)::geography))::integer\n      ELSE NULL\n    END as distance_meters\n  FROM location_predictions lp\n  JOIN locations l ON lp.location_id = l.id\n  WHERE l.active = true\n    AND (\n      user_lat IS NULL OR user_lng IS NULL OR\n      ST_DWithin(l.coordinates, ST_MakePoint(user_lng, user_lat)::geography, max_distance_meters)\n    )\n  ORDER BY \n    lp.confidence_score DESC,\n    lp.predicted_safety_score DESC,\n    distance_meters ASC NULLS LAST\n  LIMIT 10;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_nearby_locations",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_nearby_locations(lat double precision, lng double precision, radius_meters integer DEFAULT 5000)\n RETURNS TABLE(id uuid, name text, address text, place_type text, distance_meters integer, avg_safety_score numeric, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.place_type::text,\n    ROUND(ST_Distance(l.coordinates, ST_MakePoint(lng, lat)::geography))::INTEGER as distance_meters,\n    l.avg_safety_score,  -- Use the direct column\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE ST_DWithin(l.coordinates, ST_MakePoint(lng, lat)::geography, radius_meters)\n    AND l.active = true\n  ORDER BY distance_meters;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_nearby_locations_for_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.get_nearby_locations_for_user(lat double precision, lng double precision, user_race_ethnicity text[] DEFAULT NULL::text[], user_gender text DEFAULT NULL::text, user_lgbtq_status boolean DEFAULT NULL::boolean, radius_meters integer DEFAULT 5000)\n RETURNS TABLE(id uuid, name text, address text, place_type text, distance_meters integer, avg_safety_score numeric, demographic_safety_score numeric, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.place_type::text,\n    ROUND(ST_Distance(l.coordinates, ST_MakePoint(lng, lat)::geography))::INTEGER as distance_meters,\n    l.avg_safety_score,\n    COALESCE(\n      -- Try race-specific score first\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'race_ethnicity' \n         AND user_race_ethnicity IS NOT NULL \n         AND ss.demographic_value = ANY(user_race_ethnicity)\n       LIMIT 1),\n      -- Then gender-specific score\n      (SELECT ss.avg_safety_score FROM safety_scores ss \n       WHERE ss.location_id = l.id \n         AND ss.demographic_type = 'gender' \n         AND user_gender IS NOT NULL \n         AND ss.demographic_value = user_gender\n       LIMIT 1),\n      -- Fall back to overall score\n      l.avg_safety_score\n    ) as demographic_safety_score,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE ST_DWithin(l.coordinates, ST_MakePoint(lng, lat)::geography, radius_meters)\n    AND l.active = true\n  ORDER BY distance_meters;\nEND;\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.profiles (user_id)\n  VALUES (new.id);\n  RETURN new;\nEND;\n$function$\n"
  },
  {
    "function_name": "search_locations_with_coords",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.search_locations_with_coords(search_query text, result_limit integer DEFAULT 5)\n RETURNS TABLE(id uuid, name text, address text, city text, state_province text, place_type text, latitude double precision, longitude double precision)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    l.id,\n    l.name,\n    l.address,\n    l.city,\n    l.state_province,\n    l.place_type::text,\n    ST_Y(l.coordinates::geometry) as latitude,\n    ST_X(l.coordinates::geometry) as longitude\n  FROM locations l\n  WHERE (\n    l.name ILIKE '%' || search_query || '%' OR\n    l.address ILIKE '%' || search_query || '%' OR\n    l.city ILIKE '%' || search_query || '%'\n  )\n    AND l.active = true\n  ORDER BY \n    -- Prioritize name matches over address matches\n    CASE \n      WHEN l.name ILIKE '%' || search_query || '%' THEN 1\n      ELSE 2\n    END,\n    l.name\n  LIMIT result_limit;\nEND;\n$function$\n"
  },
  {
    "function_name": "test_demographic_patterns",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.test_demographic_patterns()\n RETURNS TABLE(pattern_type text, pattern_value text, user_count bigint, avg_safety_rating numeric, sample_locations text[])\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Race/ethnicity patterns\n  RETURN QUERY\n  SELECT \n    'race_ethnicity' as pattern_type,\n    race_val as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id,\n  LATERAL unnest(up.race_ethnicity) AS race_val\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL\n  GROUP BY race_val\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\n\n  -- Gender patterns  \n  RETURN QUERY\n  SELECT \n    'gender' as pattern_type,\n    up.gender as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.gender IS NOT NULL \n    AND up.gender != ''\n  GROUP BY up.gender\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\n\n  -- LGBTQ+ patterns\n  RETURN QUERY\n  SELECT \n    'lgbtq_status' as pattern_type,\n    CASE WHEN up.lgbtq_status THEN 'LGBTQ+' ELSE 'Non-LGBTQ+' END as pattern_value,\n    COUNT(DISTINCT r.user_id) as user_count,\n    ROUND(AVG(r.safety_rating), 2) as avg_safety_rating,\n    array_agg(DISTINCT l.name ORDER BY l.name) as sample_locations\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n  GROUP BY up.lgbtq_status\n  HAVING COUNT(DISTINCT r.user_id) >= 1;\nEND;\n$function$\n"
  },
  {
    "function_name": "test_extract_ml_data",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.test_extract_ml_data()\n RETURNS TABLE(user_id uuid, location_id uuid, user_race_ethnicity text[], user_gender text, user_lgbtq_status boolean, location_name text, location_type text, safety_rating numeric, overall_rating numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    r.user_id,\n    r.location_id,\n    up.race_ethnicity,\n    up.gender,\n    up.lgbtq_status,\n    l.name as location_name,\n    l.place_type::text as location_type,\n    r.safety_rating::numeric,  -- Explicit cast to numeric\n    r.overall_rating::numeric  -- Explicit cast to numeric\n  FROM reviews r\n  JOIN user_profiles up ON r.user_id = up.id\n  JOIN locations l ON r.location_id = l.id\n  WHERE r.status = 'active'\n    AND up.race_ethnicity IS NOT NULL \n    AND up.gender IS NOT NULL\n    AND up.gender != ''\n  ORDER BY r.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "trigger_calculate_safety_scores",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.trigger_calculate_safety_scores()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Add logging\n  RAISE NOTICE 'Trigger fired for location_id: %', NEW.location_id;\n  \n  -- Call the existing safety score calculation function\n  PERFORM calculate_location_safety_scores(NEW.location_id);\n  \n  RAISE NOTICE 'Safety scores calculated for location_id: %', NEW.location_id;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "update_updated_at_column",
    "complete_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$function$\n"
  }
]